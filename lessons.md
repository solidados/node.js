# NODE JS

## Цикл событий

**Преимущества**

- возможность обрабатывать большое количество операций I/O (ввода/вывода), и если они простые, то скорость достигается максимальная. (обратиться к базе данных, обработать сетевой запрос)
- Таких скоростей нельзя добиться используя **Потоки** и **Блокирующую модель поведения**

**Недостатки**

- много асинхронного кода
- сложные вычисления создают большую нагрузку (произвести сложные математические операции в цикле)

## Асинхронная модель Node.js

## Сравнение блокирующего и неблокирующего I/O

### Блокирующий I/O

- для множества соединений/запросов создаётся равноценное количество потоков (1 запрос = 1 поток)

```javascript
let user = {
  name,
  secondName
}
let conut = 0;
count += 1;
user.count = count;
databse.save(user); //! Блокируется весь поток
return user;
```

> Как только поток доходит до какой-то сложной операции, то он блокируется, и более не способен выполнять другие
> операции до завершения текущей.

Для того чтобы решить эту проблему, подобные операции выполняют в разных потоках. То есть, на уровне операционной системы создаются потоки, которые обрабатывают разные операции.

| Чтение БД | Запись файла | Обработка http-запроса |  
|-----------|--------------|------------------------|  

Самый большой минус в этом - поток потребляет огромное количество ресурсов, при этом бывают ситуации, когда поток создаётся, но какую-то часть времени он просто простаивает.

### Неблокирующий I/O

- для множества соединений/запросов создаётся один **Главный
  ** поток (`Main Thread`), который заполняется потоком "обработки данных". *Системные вызовы немедленно возвращают
  управление, не дожидаясь выполнения чтения или записи данных.* При этом Thread не блокируется.

`nginx` – использует неблокирующую модель I/O
`apache` – использует блокирующую модель I/O (***Классический многопоточный сервер***)

> Node.js работает по принципу Неблокирующей потоковой модели.

Здесь можно сказать, что Node.js является однопоточным. Это так и не так одновременно.

*Разбираемся*:  
Javascript является однопоточным, и вся **асинхронность** достигается за счёт **EventLoop**.

Node.js сам по себе – однопоточный, то есть разработчики, которые создают приложения на Node.js, пишут асинхронный код без использования потоков. Но, при этом в основе Node.js лежит библиотека `Libuv` (написана на `C`, а движок V8 на `C++`), который занимается операциями I/O.

В своей основе `Libuv` может управлять потоками, при чём **дефолтное количество потоков равно 4
**. (Это количество потоков можно изменять.)

Минусы **Неблокирующего I/O** можно выделить:  
– Операции, подобные чтению файла или записи его на диск, являются очень "тяжёлыми", так как выполняются в одном потоке, хоть и с использованием неблокирующей модели I/O. (Поэтому некоторое распараллеливание этих процессов всё же необходимо!).

Пример:

```javascript
const crypto = require('crypto');

const start = Date.now()
crypto.pbkdf2('123ttt', '5', 100000, 64, 'sha512', () => {
  console.log('1 end', Date.now() - start)
})
crypto.pbkdf2('123ttt', '5', 100000, 64, 'sha512', () => {
  console.log('2 end', Date.now() - start)
})
crypto.pbkdf2('123ttt', '5', 100000, 64, 'sha512', () => {
  console.log('3 end', Date.now() - start)
})
crypto.pbkdf2('123ttt', '5', 100000, 64, 'sha512', () => {
  console.log('4 end', Date.now() - start)
})
crypto.pbkdf2('123ttt', '5', 100000, 64, 'sha512', () => {
  console.log('5 end', Date.now() - start)
})
/*
2 end 538
1 end 601
3 end 610
4 end 619
5 end 871 <

Process finished with exit code 0
 */
```  

Как можно заметить – первые четыре потока выполнились примерно в одно и то же время, а пятый выполнился много позже.

### Планировщик потоков (Thread scheduler)

Это часть операционной системы, которая отвечает за параллельное выполнение задач, процессов, потоков. Планировщик выделяет этим процессам некоторое время, память, стек, и прочие ресурсы.

**Пул потоков
** по умолчанию имеет 4 потока. Поэтому все четыре потока были выполнены примерно в одно время. Как только один из четырёх потоков освободился, он забрал на себя пятый, который ожидал очереди.

И так, Node.js – однопоточный, и доступа к управлению потоками нет. Однако...

Начиная с версии `Node.js 11.7.0` был введён модуль `working_threads` и с помощью него можно управлять потоками.

## Шаблон Reactor

На нём построены концепции работы Node.js  
Современные операционные системы предоставляют механизм, который называется **Демультиплексор событий**.  
Именно благодаря ему *неблокирующий I/O* становится доступным.

**Демультиплексор событий**
---
> Представляет собой некоторый интерфейс уведомления о событиях. Его задача заключается в сборке, и постановке в очередь событий ввода и вывода, которые поступают из набора наблюдаемых ресурсов, а так же блокировка появления новых, доступных для обработки событий.

|        | Демультиплексор событий |            |
|--------|-------------------------|------------|
| Ресурс | Операция                | Обработчик |

Принцип работы Reactor:  
Есть некоторая очередь событий, и некоторый бесконечный цикл (EventLoop).  
EvenLoop синхронно выполняет задачи этой очереди и распределяет их дальше.  
Очередь содержит в себе некоторые события (например: было отправлено сообщение), и для каждого события устанавливается некий обработчик. В Node.js он представлен функцией обратного вызова – `Callback function`.

| Очередь событий |              |
|-----------------|--------------|
| Событие         | Обработчик** |
| Событие         | Обработчик** |
| Событие         | Обработчик** |

### Принцип ратботы

1. `Приложение` создаёт новую операцию ввода/вывода, передав запрос `Демультиплексору событий`. Так же `Приложение`
   должно определить `Обработчик` (callback-function). Функция будет вызвана тогда, когда операция будет завершена.  
   _**Важно**: отправка нового запроса к `Демультиплексору` не приводит к блокировке `Приложения`. Управление немедленно
   возвращается к `Приложению`._
2. После завершения обработки набора операций ввода/вывода, `Демультиплексор` добавляет эти события в `Очередь`.
3. `EventLoop` выполняет обход элементов в очереди событий.
4. Для каждого события вызывается соответствующий `Обработчик` (т.е. callback function).
5. (a) `Обработчик`, который является частью кода `Приложения`, возвращает управление `EventLoop`.  
   (b) Но во время работы `Обработчика`, могут запрашиваться какие-то новые асинхронные операции (например:
   прочитали инфо из БД и теперь хотим записать её в файл.) Это приводит к добавлению новых операций в
   `Демультиплексор событий` (см. шаг 1)
6. После того как `EventLoop` обработал все элементы из `Очереди`, цикл вновь заблокируется `Демультиплексором событий` и вся эта процедура начнётся с начала, когда появится новый запрос на операцию `I/O`.

![Screen Shot 2023-12-23 at 23.33.08.png](..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fc5%2F6xn41p9d25s7kg7gg2grm1hh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_cs4lwS%2FScreen%20Shot%202023-12-23%20at%2023.33.08.png)

Каждая операционная система имеет свой интерфейс для `Демультиплексора событий`.

| Linux | Windows                    | MacOS  |
|-------|----------------------------|--------|
| epoll | I/O Completion Port (IOCP) | kqueue |

## Event Loop в Node.js
![Screen Shot 2023-12-23 at 23.43.54.png](..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2Fc5%2F6xn41p9d25s7kg7gg2grm1hh0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_yGVf8X%2FScreen%20Shot%202023-12-23%20at%2023.43.54.png)
