// ! Событийно-ориентированная модель
/**
 * Модуль позволяет:
 * - создавать события
 * - подписываться на события
 * - генерировать события
 * */
const Emitter = require('events')
// const dotenv = require('dotenv')
// dotenv.config()

const emitter = new Emitter()
// ? -- (название события, callback который будет отрабатывать, когда кто-то это событие сгенерировал
// лучше вынести callback в отельную функцию и передавать её как аргумент в событие:
const callback = (data, second, third) => {
  console.log(`Вы прислали сообщение: ${data}`);
  console.log(`Второе сообщение: ${second}`);
}

emitter.on('message', callback)

const MESSAGE = process.env.TEXT || ''

// если сообщение не пустое, то будем генерировать событие:
if (MESSAGE) {
  emitter.emit('message', MESSAGE, 123)
} else {
  emitter.emit('message', 'Вы не указали текст сообщения')
}

// ? Когда удобно использовать такую концепцию?
/**
 * - при создании HTTP-серверов
 * - при обмене какими-то сообщениями
 * - когда нужно сгенерировать какое-то событие на определённое действие:
 * • http
 * • websockets
 * • long pulling
 * • clusters
 * • etc...
 *
 * Когда, при помощи `.on()` мы подписываемся на событие, то при помощи `.emit()`
 * мы можем генерировать его неограниченное количество раз.
 *
 * Но возникают ситуации, когда событие необходимо сгенерировать лишь один раз:*/

emitter.once('message', () => {
  console.log('Это событие завершено...');
})

// ? -- .removeListener(...) удаление конкретного слушателя
emitter.removeListener('message', callback)
// Здесь callback передаётся в аргументы ремувера потому, что на одно и то же событие 'message' (например),
// мы можем вещать различные callbacks. И чтобы завершить конкретное событие с конкретным callback, его
// необходимо передать в ремувер;

// ? -- удаление всех слушателей
emitter.removeAllListeners()
